class LocalDb{#e;#t;#s;#a=null;#o=!1;#r;#n;constructor({apiUrl:e,dbName:t,storeName:s}){this.#e=e,this.#t=t,this.#s=s,this.ready=new Promise((e=>{this.#r=e})),this.#i()}async#i(){try{if(await this.#c()){await this.#l()||(console.warn("資料庫 keyPath 不正確，刪除並重新建立資料庫。"),await this.#m())}else console.warn("資料庫不存在，刪除舊版本並重新建立..."),await this.#m();await this.checkAndFetchData()}catch(e){console.error("初始化資料庫時發生錯誤:",e)}}async#c(){return new Promise(((e,t)=>{const s=indexedDB.open(this.#t);s.onsuccess=t=>{const s=t.target.result,a=Array.from(s.objectStoreNames);s.close(),e(a.includes(this.#s))},s.onerror=e=>{console.error("檢查資料庫存在時發生錯誤:",e.target.error),t(e.target.error)},s.onupgradeneeded=()=>{e(!1)}}))}async#l(){return new Promise((e=>{const t=indexedDB.open(this.#t);t.onsuccess=t=>{const s=t.target.result,a=s.transaction(this.#s,"readonly").objectStore(this.#s);e("compositeKey"===a.keyPath),s.close()},t.onerror=()=>e(!1)}))}async#m(){return new Promise(((e,t)=>{const s=indexedDB.deleteDatabase(this.#t);s.onsuccess=()=>{console.log(`資料庫 ${this.#t} 已刪除`),e()},s.onerror=e=>{console.error("刪除資料庫時發生錯誤:",e.target.error),t(e.target.error)},s.onblocked=()=>{console.warn("刪除資料庫被阻塞。請關閉其他使用此資料庫的連線。")}}))}async checkAndFetchData(){const e=await this.getLastInsertTimeFromDB(),t=await this.getLastUpdateTimeFromDB();if(t&&this.isToday(t.lastUpdateTime))console.log("資料已是今日最新，無需更新。"),this.#a=e.lastInsertTime;else{const t=await this.fetchDataFromApi(null==e?e:e.lastInsertTime);this.shouldUpdateData(t.lastInsertTime)&&await this.updateLocalData(t),this.#a=t.lastInsertTime}this.#o=!0,this.#r()}async fetchDataFromApi(e){const t=await fetch(this.#e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({LastInsertTime:e})});if(!t.ok)throw new Error("Failed to fetch data");return t.json()}shouldUpdateData(e){return e!==this.#a}async updateLocalData(e){const t=(await this.openDatabase()).transaction([this.#s],"readwrite"),s=t.objectStore(this.#s);return new Promise(((a,o)=>{e.keys.forEach((e=>{e.type="remote";const t=`${e.key}|${e.type}`,a=s.get(t);a.onsuccess=a=>{const o=a.target.result;o?(o.times+=e.times||0,s.put(o)):s.put({compositeKey:t,key:e.key,type:e.type,times:e.times||0})},a.onerror=e=>o(e)})),s.put({compositeKey:"lastInsertTime",lastInsertTime:e.lastInsertTime}),s.put({compositeKey:"lastUpdateTime",lastUpdateTime:new Date}),t.oncomplete=()=>a(),t.onerror=e=>o(e)}))}async openDatabase(){return this.#n?this.#n:new Promise(((e,t)=>{const s=indexedDB.open(this.#t,1);s.onupgradeneeded=e=>{const t=e.target.result;t.objectStoreNames.contains(this.#s)||t.createObjectStore(this.#s,{keyPath:"compositeKey"})},s.onsuccess=t=>e(t.target.result),s.onerror=e=>t(e)}))}async getLastInsertTimeFromDB(){const e=(await this.openDatabase()).transaction([this.#s],"readonly").objectStore(this.#s);return new Promise(((t,s)=>{const a=e.get("lastInsertTime");a.onsuccess=e=>{const s=e.target.result;t(s||null)},a.onerror=e=>s(e)}))}async getLastUpdateTimeFromDB(){const e=(await this.openDatabase()).transaction([this.#s],"readonly").objectStore(this.#s);return new Promise(((t,s)=>{const a=e.get("lastUpdateTime");a.onsuccess=e=>{const s=e.target.result;t(s||null)},a.onerror=e=>s(e)}))}isToday(e){const t=new Date,s=new Date(e);return t.getFullYear()===s.getFullYear()&&t.getMonth()===s.getMonth()&&t.getDate()===s.getDate()}async getData(){this.#o||await this.ready;const e=(await this.openDatabase()).transaction([this.#s],"readonly").objectStore(this.#s);return new Promise(((t,s)=>{const a=e.getAll();a.onsuccess=e=>{const s=e.target.result.filter((e=>"lastUpdateTime"!==e.compositeKey&&"lastInsertTime"!==e.compositeKey)).map((e=>({key:e.key,type:e.type,times:e.times}))).sort(((e,t)=>t.times-e.times));t(s)},a.onerror=e=>s(e)}))}async addOrUpdateData(e,t="local"){this.#o||await this.ready;const s=(await this.openDatabase()).transaction([this.#s],"readwrite"),a=s.objectStore(this.#s);return new Promise(((o,r)=>{const n=`${e}|${t}`,i=a.get(n);i.onsuccess=i=>{const c=i.target.result;c?(c.times++,a.put(c)):a.put({compositeKey:n,key:e,type:t,times:1}),s.oncomplete=()=>o(!0),s.onerror=e=>r(e)},i.onerror=e=>r(e)}))}async deleteData(e){const t=`${e}|local`,s=await this.openDatabase();console.log(this.#s);const a=s.transaction([this.#s],"readwrite").objectStore(this.#s);return new Promise(((e,s)=>{const o=a.delete(t);o.onsuccess=()=>{console.log(`成功刪除本機資料: ${t}`),e()},o.onerror=e=>{console.error(`刪除失敗: ${t}`,e),s(e)}}))}async clearLocalData(){try{const e=await this.openDatabase(),t=e.transaction([this.#s],"readwrite").objectStore(this.#s);return new Promise(((e,s)=>{const a=t.openCursor(),o=[];a.onsuccess=s=>{const a=s.target.result;if(a){const e=a.key;e.endsWith("|local")&&o.push(e),a.continue()}else o.forEach((e=>{t.delete(e)})),console.log("成功清空本地紀錄"),e()},a.onerror=e=>{console.error("清空本地紀錄時發生錯誤:",e),s(e)}}))}catch(e){throw console.error("清空本地資料時發生錯誤:",e),e}}}